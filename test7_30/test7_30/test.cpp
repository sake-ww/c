#define _CRT_SECURE_NO_WARNINGS 1


1.c++98标准关键字-- - 63
2.命名空间：在C++中定义一个命名空间，相当于定义了一个作用域，（在c语言中我们的作用域一共有两个，一个 全局作用域 ，和函                    数体中的局部作用域）
2.1命名空间作用：解决命名冲突（可以理解为命名空间出现的作用就是为解决c语言中的命名冲突）
c语言中要解决全局变量或者全局函数命名冲突，只有一个方法：让这些冲突的名字不一样
（怎么不一样？我们尽可能让这个名字复杂，长度长，名字复杂敲代码就不容易）
2.2命名空间的定义方式：
namespace N
{
	成员：变量 函数 结构体 其他。。。
}
2.3命名空间可以嵌套：在一个命名空间中还可以继续定义命名空间
在同一个工程中可以定义多个相同的命名空间，最终 : 编译器会将相        同名称的命名空间合并成一个
						  2.4命名空间中成员的使用方式：
						  >> 直接在成员前加命名空间名字::，比如：  N::a-->访问N命名空间中的a
						  >> 命名空间中的某些成员在当前文件中频繁的访问，如果每次都N::a这样访问，在成员前加命名空间的名字，就太麻烦了--->using N::a; a相当于当前文件中的一个全局变量，注意可能会发生冲突，万一冲突添加命名空间名字以及作用域限定符
						  >> 命名空间中许多成员在当前文件中频繁的访问，方式一和方式二都有点麻烦，using namespace N  N命名空间中的成员就可以在当前文件中直接使用-- - 注意：可能会发生冲突，添加命名空间名字以及作用域限定符
						  3.C++输入和输出：
						  cin来进行标准输入--数据是通过键盘来输入的
						  cout来进行标准输出--数据输出到控制台
						  cin和cout最大的优势：不需要记忆格式控制
						  int a；  double b；  char c；
						  cin >> a >> b >> c;
cout << a << " " << b << " " << c << endl;
注意：在使用时，需要添加<iostream>和std
即：#include<iostream>
using namespace std;
注意：C++为了和c语言区分，C++标准库给出的头文件基本都没有.h（老版本中有.h）看书时，有些书包包含的头文件:iostream.h--》说明在写书的时候年代比较久远，用的编译器比较旧。现在的vs2010，vs2013及以上的版本都已经不支持旧的库
4.函数方面的区别：
4.1参数类表：
在c语言中，如果一个函数没有参数，可以传递任意多个参数----c语言编译器对函数参数检测不严格
在c语言中，如果一个函数没有参数时，必须明确指定函数的参数类型是void-- - 》void testFunc（void）；
在c++中不同，如果一个函数：void testFunc()--->表明该函数没有参数，如果在调用时传参编译器会报错
C++的编译器对函数参数检测更加严格
4.2返回值不用：
在c语言中，如果一个函数没有显示给出返回值类型 testFunc(){} c语言编译器认为该函数返回一个整形；
c语言编译器对返回值类型检测不严格
在C++中，如果一个函数没有显示给出返回值类型 testFunc（）{} 则编译失败
c++编译器对返回值类型检测非常严格
5.在c++中一个函数的参数可以带默认值
缺省参数：类似一个备胎
缺省参数是声明或定义函数时为函数的参数指定一个默认值。在调用该函数时，如果没有指定实参则采用该
默认值，否则使用指定的实参。

6.引用
c语言中函数传参有几种方式？有什么区别？有什么优缺点？
期望：能否有类型可以按照值的方式传参，但是可以达到指针的效果--用形参给实参取别名--引用
引用
1.概念：引用更不是新定义一个变量，而是给已存在变量取了一个别名，它和它引用的实体公用同一个实体，编译器不会给引用变量重新开辟内存空间
2.引用定义格式：类型& 引用变量名字 = 实体；
注意：引用变量类型必须与其实体的类型一致
3.引用的性质：引用在定义时必须初始化；  引用一旦与某个实体结合，在不能引用其他实体；  一个变量可以有多个引用
4.const类型的引用
const int a = 10；  const int& ra = a；
const int& b = 10；
double d = 12.34; int& rd = d; 不行
double d = 12.34; const int& rd = d; 行
整型类型的变量去引用double的变量显然不行
double可以与int进行隐式类型转化
在其中过程中创建了一个临时变量 ，此时引用的不是double，而是一个临时空间，我们即不知道它的名字，也不知道它的地址，想要对其进行修改-- - 不行
5.引用的应用场景
5.1写代码简单
a.b_b = 10；a结构体里面有一个b成员，我们需要引用a中b中b，这样写麻烦所以我们这样写：int& b = a.b_b; b = 10; 我们就可以直接改变a中b中b
5.2函数参数
void f(T& a); 可以通过形参a改变外部的实参
void f(const T& a); 如果不想通过形参修改外部实参，最该将参数使用const来进行限制，程序的安全性就会高
5.3函数返回值：
注意一定不能返回函数栈上的空间
