#define _CRT_SECURE_NO_WARNINGS 1

#include"SList.h"
int  main()
{
	TestSList();
	return 0;
}

//题外延申：
//if 0
//。。。。。
//endif
//屏蔽代码

//一个程序从写完到可以执行起来，需要经过一下几个步骤：预处理--》编译--》汇编--》链接--》生成可执行程序
//程序链接出错
//错误中：无法解析的外部符号--（问题出自于）--》链接

//c语言中的传参方式
//值传递：形参（left，right）是实参（a，b）的一份拷贝，在函数中交换的是形参（即实参的拷贝）
//        形参与实参没有任何关联--》在函数中最形参进行修改不会影响外部的实参
//值传递
//void Swap(int left, int right)
//{
//	int temp = left;
//	left = right;
//	right = temp;
//}
//int  main()
//{
//	int a = 10;
//	int b = 20;
//
//	Swap(a,b);
//	printf("%d %d", a, b);
//	return 0;
//}

//传地址：pa，pb实际指向 的就是实参a，b
//        在函数中对形参指向空间中的内容进行修改，实际修改的就是实参本身
//void Swap(int* pa, int* pb)
//{
//	int temp = *pa;
//	*pa = *pb;
//	*pb = temp;
//}
//int  main()
//{
//	int a = 10;
//	int b = 20;
//
//	Swap(&a, &b);
//	printf("%d %d", a, b);
//	return 0;
//}
 
//在Swap函数中如果想要交换外部两个指针实参的指向，必须传递二级指针
//void Swap(int** pleft, int** pright)
//{
//	int* temp = *pleft;
//	*pleft = *pright;
//	*pright = *temp;
//
//}
//
//int  main()
//{
//	int a = 10;
//	int b = 20;
//	 
//	int* p1 = &a;
//	int* p2 = &b;
//
//	//通过Swap函数交换p1和p2两个指针的指向
//	Swap(&p1, &p2);
//
//	printf("%d %d", a, b);
//	return 0;
//}
//传参总结：
//传值：实参是形参的一份拷贝，不能通过形参改变外部的实参
//传地址：形参中就是实参的地址，可以通过对形参解引用拿到实参。可以通过修改形参来达到对实参的改变
//因此：如果想要通过形参来改变实参，必须传递实参的地址
//如果实参是普通类型的变量比如：int a ---》&a--》一级指针
//如果实参是指针类型--》int* pa = &a；在函数中想要修改实参pa的指向，必须要传递pa的地址，即int** 二级指针

//我们需要不带头的单链表，链表里面都是由一个一个节点构成的，我们需要
//将链表组织起来，我们只需要一个指针，这个指针指向链表中的第一个节点
//如果链表里面没有放节点，接下来我们需要放节点，刚开始我们需要
//Node*  head = NULL; 
//然后我们需要通过
//SListPushBack(head,1);
//1.申请新节点newNoad
//2.尾插新节点
//  （1）head为NULL：链表中没有节点，head指向newNode
//  （2）head不为NULL：链表中已经有节点
//       找到链表中的最后一个节点--》如果某个节点的next域指向空，则该节点为最后一个节点
//       将新节点链接到最后一个节点之后

//如果想要在函数中用过形参改变外部的实参，则必须传递实参的地址
//难点：在函数中想要通过形参改变外部实参指针的指向，则必须传递外部实参指针的地址

//不论是值传参还是指针传参，在传参过程中都会生成一份拷贝
//（如果是值，那么会生成一份值的拷贝，如果是指针，则会生成一份指针的拷贝，
//  如果在函数中改变函数的指向，他最终改变的是副本的指向）

//对于链表的基本操作中，哪些方法需要传递二级指针，哪些方法需要传递一级指针？
//本质：在函数体中是否需要通过形参指针改变外部实参指针的指向
//      需要：函数的参数必须为二级指针
//            比如：所有的插入，删除，销毁
//      不需要：函数的参数只需要传递一级指针
//              比如：查找，获取有效节点的个数

//参数检测
//有些情况下使用assert：该种问题如果发生，程序是一张错误--》除法的除数为零
//有些情况下使用if判断：该种问题如果发生，程序是一种正常的情况，--》空链表--》合法的链表，只不过链表中没有节点而已

//free(cur)
//注意：不是销毁cur本身，二十销毁cur指向的那个节点
//free（void* addr）：释放addr表示的空间
