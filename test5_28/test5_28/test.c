#define _CRT_SECURE_NO_WARNINGS 1

//宏相比较于函数的优点：
//1. 用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。所以宏比函数在程序的规模和速度方面更胜一筹。
//2. 更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之这个宏怎可以适用于整形、长整型、浮点型等可以用于>来比较的类型。宏是类型无关的。
//3. 宏有时候可以做函数做不到的事情。比如：宏的参数可以出现类型，但是函数做不到。

//【3. 宏有时候可以做函数做不到的事情。比如：宏的参数可以出现类型，但是函数做不到。】
//举例：
//#define SIZEOF(type) sizeof(type)
//int main()
//{
//	int ret = SIZEOF(int);
//	//int ret = sizeof(int);
//	printf("%d\n", ret);//4
//	return 0;
//}

//我们平常使用malloc时，特别别扭，int* p = (int*)malloc(10*sizeof(int));我们要计算大小，还要强制类型转换，感觉挺复杂的
//#define MALLOC(num, type) (type*)malloc(num*sizeof(type))
//int main()
//{
//	int* p = (int*)malloc(10*sizeof(int));
//	
//	int* p = MALLOC(10, int);
//	//int* p = (int*)malloc(10 * sizeof(int));
//	return 0;
//}

//宏相比较于函数的缺点：
//1. 每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序的长度。
//解释：宏可以定义一段很长的代码，当函数运行的时候，我们引用了这段宏很多次，那么这整个代码则会特别长
//2. 宏是没法调试的。
//3. 宏由于类型无关，也就不够严谨。
//4. 宏可能会带来运算符优先级的问题，导致程容易出现错。
//函数传值的时候是先计算，然后再传，宏直接替换

//总结：
//属性                    #define定义宏                                            函数
//代码长度          每次使用时，宏代码都会被插入到程序中。除了非常小的宏    函数代码只出现于一个地方；每次使用这
//                  之外，程序的长度会大幅度增长                            个函数时，都调用那个地方的同一份代码
//执行速度          更快                                                    存在函数的调用和返回的额外开销，所以相对慢一些
//操作符优先级      宏参数的求值是在所有周围表达式的上下文环境里，除非加    函数参数只在函数调用的时候求值一
//                  上括号，否则邻近操作符的优先级可能会产生不可预料的后    次，它的结果值传递给函数。表达式
//                  果，所以建议宏在书写的时候多些括号。                    的求值结果更容易预测。
//带有副作用的参数  参数可能被替换到宏体中的多个位置，所以带有副作用的参    函数参数只在传参的时候求值一次，
//                  数求值可能会产生不可预料的结果。                        结果更容易控制。
//参数类型          宏的参数与类型无关，只要对参数的操作是合法的，它就可    函数的参数是与类型有关的，如果参数的类型不同，
//                  以使用于任何参数类型。                                  就需要不同的函数，即使他们执行的任务是不同的。
//调试              宏是不方便调试的                                        函数是可以逐语句调试的
//递归              宏是不能递归的                                          函数是可以递归的


//命名约定：
//一般来讲函数的宏的使用语法很相似。所以语言本身没法帮我们区分二者。 那我们平时的一个习惯是：
//把宏名全部大写 函数名不要全部大写
