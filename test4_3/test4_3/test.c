#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>
int main()
{
	int n = 9;
	float *pFloat = (float *)&n;
	printf("n的值为：%d\n", n);               //9                            1
	printf("*pFloat的值为：%f\n", *pFloat);   //0.000000                     2
	*pFloat = 9.0; 
	printf("num的值为：%d\n", n);             //109 156 7616                 3
	printf("*pFloat的值为：%f\n", *pFloat);   //9.000000                     4
	return 0;
}

//9
//s    e         m
//0 00000000 000000000000000001001-----原反补相同视为补码
//内存中e在其中存储是  需要加  127（128-1）（128=2^8）   e为八位时
//                             1023                      e为11位时
//1---------正常理解
//2---------这个题将 补码 视为  小数  存储的方法  因为E为00000000   表示一个无限接近0的一个数字，因为float只能表示小数后六位，所以为此结果
//0 10000010 001000000000000000000------这个即为9.0在内存中的二进制存储方法
//0100 0001 0001 0000 0000 0000 0000 0000 
//8     1     1   0    0    0    0    0-----------81 11 00  00 
//在内存中的存储方法为 0x 00 00 11 81
//3---------010000010001000000000000000000  直接读了，所以为，，，
//4---------正常理解

//举例来说： 十进制的5.0，   写成二进制是 101.0 ，  相当于 1.01×2 ^ 2 。 那么，按照上面V的格式，可以得出s = 0，M = 1.01，E = 2。
//           十进制的 - 5.0，写成二进制是 - 101.0 ，相当于 - 1.01×2 ^ 2 。那么 ，                       s = 1，M = 1.01，E = 2。

//举例：5.5
//101.1
//-1^0 * 1.011 * 2^2
//   s    m        e=2+127
//0 10000001 01100000000000000000000
//s   e        m

//举例：0.5
//0.1
//-1^0 * 1.0 * 2 -1
//s        m     e=-1 + 127
//0 01111110 00000000000000000000000
//s   e        m

//总结：0.XXXXX 将其表示为  1.XXXXXX * 2^XXXX  便可，
//      因为其他数字表示起来特别困难，所以，一般举例为0.5。
//这种题为 延伸类 ，不需要掌握，但是知道方法以后可以更加方便的查出bug。

//输入成绩得到 ABCD   这个比较复杂，但是这个也是练习switch语句的方法
//#include <stdio.h>
//int main()
//{
//	int a,b;
//	scanf("%d", &a);
//	b = a / 5;
//	if (b >= 0 && b <= 20)
//	{
//		switch (b)
//		{
//		case 20:
//		case 19:
//		case 18:
//			printf("A\n");
//			break;
//		case 17:
//		case 16:
//		case 15:
//			printf("B\n");
//			break;
//		case 14:
//		case 13:
//			printf("C\n");
//			break;
//		default:
//			printf("D\n");
//			break;
//		}
//	}
//	else
//		printf("输入错误！");
//	return 0;
//
//}