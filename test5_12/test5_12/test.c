#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//文件缓冲区:
//ANSIC 标准采用“缓冲文件系统”处理的数据文件的，所谓缓冲文件系统是指系统自动地在内存中为程序中每一个正在
//使用的文件开辟一块“文件缓冲区”。从内存向磁盘输出数据会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘
//上。如果从磁盘向计算机读入数据，则从磁盘文件中读取数据输入到内存缓冲区（充满缓冲区），然后再从缓冲区逐
//个地将数据送到程序数据区（程序变量等）。缓冲区的大小根据C编译系统决定的。

//图形解释
//           ->输出缓冲区\
//	     /              -- - 输出--->
//程序数据区                          磁盘
//          \            <---输入---/
//		  ->输入缓冲区/

//操作解释
//在虚拟机中输入下面代码
//int main()
//{ 
//	while (1)
//	{
//		printf("hehe");
//	}
//	return 0;
//}
//结果：一直输出hehehehehe......
//接下来输入这段代码：
//#include<windows.h>
//int main()
//{ 
//	while (1)
//	{ 
//		Sleep(1);
//		printf("hehe");
//	}
//	return 0;
//}
//然后运行
//此时不会和第一次一样出现输出结果
//推断：你每间隔一毫秒时间输入进去一个hehe，需要将输入缓冲区塞满，才会正常运行
//代码运行结果：运行后，间隔一段时间后，屏幕会出现一大堆hehe...然后在等一段时间，又会出现一大堆hehe...
//原因：输入缓冲区是有大小的
//图形解释：
//               输入缓冲区
//printf--输出-->hehe......--->屏幕



//文件指针
//缓冲文件系统中，关键的概念是“文件类型指针”，简称“文件指针”。
//每个被使用的文件都在内存中开辟了一个相应的文件信息区，用来存放文件的相关信息（如文件的名字，文件状态及
//文件当前的位置等）。这些信息是保存在一个结构体变量中的。该结构体类型是有系统声明的，取名FILE..
//通俗解释：
//假如，你写了一个文件 test.txt ，然后你想运行这个文件，此时便会开辟一个相应的文件信息区，用来存放文件的
//相关信息（如文件的名字，文件状态及文件当前的位置等）。这些信息会保存在一个struct _iobuf的结构体变量里面
//系统将他命名为FILE，每次用这些信息时，就通过FILE这个指针来寻找相应的信息。(仅个人对文件指针的理解，仅供
//参考，如有不妥，请指正)

//对于FILE:右键FILE点击转到定义，里面会有这样的一段代码
//#ifndef _FILE_DEFINED
//struct _iobuf {
//	char *_ptr;
//	int   _cnt;
//	char *_base;
//	int   _flag;
//	int   _file;
//	int   _charbuf;
//	int   _bufsiz;
//	char *_tmpfname;
//};
//typedef struct _iobuf FILE;
// 将struct _iobuf 这个结构体起名为FILE

//文件的打开和关闭
//文件在读写之前应该先‘打开文件’，在使用结束之后应该‘关闭文件’。

//在编写程序的时候，在打开文件的同时，都会返回一个FILE*的指针变量指向该文件，也相当于建立了指针和文件的关系。
//ANSIC 规定使用fopen函数来打开文件，fclose来关闭文件。

//FILE * fopen(const char * filename, const char * mode);
//打开文件用的是fopen
//char*是一个字符指针
//filename是文件名
//引文文件传过去传的是受地址，所以是char*
//mode是打开模式方式
//int fclose(FILE * stream);//关闭文件//打开方式如下：（mode）//文件使用方式      含义                                        如果指定文件不存在
//“r”（只读）     为了输入数据，打开一个已经存在的文本文件    出错
//“w”（只写）     为了输出数据，打开一个文本文件              建立一个新的文件
//“a”（追加）     向文本文件尾添加数据                        出错
//“rb”（只读）    为了输入数据，打开一个二进制文件            出错
//“wb”（只写）    为了输出数据，打开一个二进制文件            建立一个新的文件
//“ab”（追加）    向一个二进制文件尾添加数据                  出错
//“r + ”（读写）  为了读和写，打开一个文本文件                出错
//“w + ”（读写）  为了读和写，建议一个新的文件                建立一个新的文件
//“a + ”（读写）  打开一个文件，在文件尾进行读写              建立一个新的文件
//“rb + ”（读写） 为了读和写打开一个二进制文件                出错
//“wb + ”（读写） 为了读和写，新建一个新的二进制文件          建立一个新的文件
//“ab + ”（读写） 打开一个二进制文件，在文件尾进行读和写      建立一个新的文件
//举例：
//     “r”（只读）     为了输入数据，打开一个已经存在的文本文件    出错
//下面为测试代码，先检查一下写的文件是否存在，防止重复（刚才已经创建了一个文件，防止相互干扰）
//int main()
//{
//	//打开文件 
//	//相对路径的写法
//	fopen("test.txt","r");	
//	//.. 表示上一级路径
//	//.  表示当前路径
//	//举例：test.txt这个文件的上一个路径也有一个test.txt如果想打开这个文件则需要输入下面代码
//	//fopen("../test.txt","r");
//	//如果还想写这个上一个路径（即第一个的上上路径）
//	//fopen("../../test.txt","r");
//
//
//	//文件有很多，为了防止重名，可以用 
//	//绝对路径的写法
//	//例如：
//	fopen("C:\\Users\\wyw15\\Desktop\\新建代码1\\test5_12\\test5_12\\test.txt", "r");
//	return 0;
//}

//strerror(errno)需要引用两个头文件
#include<errno.h>
#include<string.h>

//int main()
//{
//	//FILE* pf = fopen("tesrt.txt", "r");
//	//fopen("tesrt.txt", "r")打开文件会返回一个指针，我们用pf接收他
//	//当然可能会打开成功，也会打开失败，如果打开失败，则会返回一个NULL
//
//	//这个会打开或创建一个文件（test.txt）并在这个文件中的内存中开头创建一个文件信息区
//	//这个文件信息区里面放的就是这个文件的相关信息，这个能够更好的管理这个文件（test.txt）
//	//它的类型就是FILE的一种结构体变量，他的起始位置就会按照指针的形式返回即pf，
//	
//	FILE* pf = fopen("test.txt", "r");
//	//打开失败
//	if (pf == NULL)
//	{
//		printf("%s\n",strerror(errno));
//		//strerror(errno)这个能够获取这个错误代码的错误信息
//		//printf("%s\n",strerror(errno));这样可以把这个信息打印出来 
//		return 0;
//	}
//	//打开成功
//	//读文件
//	//关闭文件
//	fclose(pf);
//	pf = NULL;
//	return 0;
//	//因为你是以'读的形式'(r)打开，因为没有这个文件所以会打开失败
//	//出现：No such file or directory
//
//	//当你创建一个文件 test.txt 时，此时你运行代码
//	//没有任何问题
//}


//int main()
//{
//	FILE* pf = fopen("test.txt", "w");
//	if (pf == NULL)
//	{
//		printf("%s\n",strerror(errno)); 
//		return 0;
//	}
//	fclose(pf);
//	pf = NULL;
//	return 0;
//}
//如果你以写的形式‘w’打开，即使不创建文件test.txt也会没有任何问题，他会自动生成一个文件test.txt
//详情请参考上面‘打开方式如下：（mode）’表
//如果此时你在外面打开这个文件test.txt并往里面放一个信息（abcdef）（随便）然后运行这个代码，
//然后在外面打开这个文件，会发现这个文件里面的内容会消失不见
//即：你以写的形式打开旧文件，会创建一个新文件，并覆盖这个文件
//详情请参考上面‘打开方式如下：（mode）’表


//文件的顺序读写
//功能               函数名       适用于
//字符输入函数       fgetc        所有输入流
//字符输出函数       fputc        所有输出流
//文本行输入函数     fgets        所有输入流
//文本行输出函数     fputs        所有输出流
//格式化输入函数     fscanf       所有输入流
//格式化输出函数     fprintf      所有输出流
//二进制输入         fread        文件
//二进制输出         fwrite       文件
//这些可以用在msdn中查找，里面有相关知识

//举例：写
//int main()
//{
//	FILE* pfWrite = fopen("TEST.txt", "w");
//	if(pfWrite == NULL)
//	{
//		printf("%s\n", strerror(errno));
//		return 0;
//	}
//	//写文件
//	fputc('a', pfWrite);
//	fputc('b', pfWrite);
//	fputc('c', pfWrite);
//	
//	//关闭文件
//	fclose(pfWrite);
//	pfWrite = NULL;
//
//	return 0;
//}
//运行这个代码，程序正常进行
//此时你在外面打开文件TEST.txt，会发现里面有 abc

//不要删除外面的文件TEST.txt，
//此时运行读
//int main()
//{
//	FILE* pfRead = fopen("TEST.txt", "r");
//	if(pfRead == NULL)
//	{
//		printf("%s\n", strerror(errno));
//		return 0;
//	}
//	//读文件
//	printf("%c", fgetc(pfRead));//b
//	printf("%c", fgetc(pfRead));//i
//	printf("%c", fgetc(pfRead));//t
//
//	//关闭文件
//	fclose(pfRead);
//	pfRead = NULL;
//
//	return 0;
//}
//运行代码：adc 

//延申：
//从键盘输入
//输出到屏幕.
//键盘&屏幕都是外部设备
//我们可以 读写 外部设备

//键盘-标准输入设备- stdin
//屏幕-标准输出设备- stdout
//是一个程序默认打开的两个流设备
//只要我们的程序运行起来，就会默认打开三个 流

//stdin FILE*
//stdout FILE*
//stderr FILE*
//类型都是FILE


//功能               函数名       适用于
//字符输入函数       fgetc        所有输入流
//字符输出函数       fputc        所有输出流
//文本行输入函数     fgets        所有输入流
//文本行输出函数     fputs        所有输出流
//格式化输入函数     fscanf       所有输入流
//格式化输出函数     fprintf      所有输出流
//这里的fgetc fputc...适用于所有流
//int main()
//{
//	int ch = fgetc(stdin);
//	//fgetc读取一个字符，从stdin流里面读取，并存储到ch里面
//	fputc(ch, stdout);
//	//再把ch打印出来
//	//从键盘输入，从屏幕读
//	return 0;
//}
//程序运行：你从键盘随便输入一个字符或者数字，enter。屏幕会出现你输入的字符或数字
//此时你可以发现fgetc可以从标准输入流输入，从标准输出流输出
//即：从键盘输入，从屏幕看到
