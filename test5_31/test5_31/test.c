#define _CRT_SECURE_NO_WARNINGS 1
//时间复杂度
//空间复杂度

//引入：
//int Fib(int N)
//{
//	if (N < 3)
//		return 0;
//	return Fib(N - 1) + Fib(N - 2);
//}
//递归类型的代码，用以 斐波那契数列
//如何衡量一个算法的好坏？(速度快，占用内存小)
//一个算法的复杂度进行衡量
//时间复杂度
//空间复杂度
//本质：都是求数学表达式--某条基本语句关于问题规模N的数学表达式

//1.算法效率
//算法效率分析分为两种：第一种是时间效率，第二种是空间效率。时间效率被称为时间复杂度，而空间效率被称作空间复杂度。 时间复杂度主要衡量的是一个算法的运行速度，而空间复杂度主要衡量一个算法所需要的额外空间，在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。

//2.时间复杂度
//2.1 时间复杂度的概念
//    时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。
//    理解：是一个关于问题规模N的数学表达式，计算算法中某条基本语句总的执行次数
//2.2 大O的渐进表示法

//请计算一下Func1基本操作执行了多少次？（++count这个执行了多少次）
//void Func1(int N)
//{
//	int count = 0;
//	for (int i = 0; i < N; ++i)
//	{
//		for (int j = 0; j < N; ++j)
//		{
//			++count;
//		}
//	}
//	for (int k = 0; k < 2 * N; ++k)
//	{
//		++count;
//	}
//	int M = 10;
//	while (M--)
//	{
//		++count;
//	}
//	printf("%d\n", count);
//}
//F(N) = N^2 + 2 * N +10
//N = 10 F(N) = 130
//N = 100 F(N) = 10210
//N = 1000 F(N) = 1002010
//实际中我们计算时间复杂度时，我们其实并不一定要计算精确的执行次数，而只需要大概执行次数，那么这里我们使用大O的渐进表示法。
//大O符号（Big O notation）：是用于描述函数渐进行为的数学符号。
//推导大O阶方法：
//先计算出数学表达式，按照以下规则来进行处理 
//1、用常数1取代运行时间中的所有加法常数。
//例如：某个代码运行次数：F(N)=100
//      O(F(N))=O(100)---->O(1)
//2、在修改后的运行次数函数中，只保留最高阶项。
//   对于Func1 我们知道：F(N) = N^2 + 2 * N +10
//   O(F(N)) ---> O(N^2 + 2 * N +10)  ---> O（N^2）
//3、如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。
//使用大O的渐进表示法以后，Func1的时间复杂度为：
//O（N^2）
//N = 10 F(N) = 100
//N = 100 F(N) = 10000
//N = 1000 F(N) = 1000000
//通过上面我们会发现大O的渐进表示法去掉了那些对结果影响不大的项，简洁明了的表示出了执行次数。

//另外有些算法的时间复杂度存在最好、平均和最坏情况：
//最坏情况：任意输入规模的最大运行次数(上界)
//平均情况：任意输入规模的期望运行次数
//最好情况：任意输入规模的最小运行次数(下界)
//例如：在一个长度为N数组中搜索一个数据x
//最好情况：1次找到
//最坏情况：N次找到
//平均情况：N / 2次找到
//在实际中一般情况关注的是算法的最坏运行情况，所以数组中搜索数据时间复杂度为O(N)

//时间复杂度为什么要总次数作为参考，而不是以时间参考？
//应该将算法放在不同的机器中进行衡量： 
//不同机器里面运行的时间不同，则没有实际价值（硬件环境不同，时间没有参考价值）
//在一台机器上运行代码，此时机器运行的不止你一个代码，还有别的程序
//在不同的机器运行我们的程序，我们的程序运行的次数是一定的
