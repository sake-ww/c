#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <stdlib.h>//malloc
//柔性数组的特点：
//1.结构中的柔性数组成员前面必须至少一个其他成员。（即int arr[]上面还要至少有一行代码）

//struct S
//{
//	int n;
//	char c;
//	int arr[0];//这里的零没有任何意义，只是一种语法形式而已
//	           //此时就可以把arr叫做：柔性数组成员
//	           //未来可以控制这个数组的大小
//};

//有一些编译器不支持上面写法，则可以用下面的写法代替
//两者效果等同
//struct S
//{
//	int n;
//	int arr[];
//};
//
//int main()
//{
//	return 0;
//}
//int arr[0];在主函数中不能这样创建一个大小为零的数组，但是在结构体中可以这样创建。
//----------------------------------------------------------------------------------------
//2.sizeof 返回的这种结构大小不包括柔性数组的内存。

//struct S
//{
//	int n;//4
//	int arr[];
//};
//
//int main()
//{
//	printf("%d\n", sizeof(struct S));
//	return 0;
//}
//输出结果为：4
//---------------------------------------------------------------------------------------------
//3.包含柔性数组成员的结构用malloc()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应
//柔性数组的预期大小。

//struct S
//{
//	int n;//4
//	int arr[];//10
//};
//
//int main()
//{
//	int i = 0;
//	struct S* p = (struct S*)malloc(sizeof(struct S)+10*sizeof(int));
//	p->n = 100;
//	for(i=0; i<10; i++)
//	{
//		p->arr[i] = i;
//	}
//	for(i=0; i<10; i++)
//	{
//		printf("%d ", p->arr[i]);
//	}
//	printf("%d ", p->n);
//	free(p);
//    p = NULL;
//	
//	return 0;
//}
//输出：0 1 2 3 4 5 6 7 8 9 100

struct S
{
	int n;
	int*arr;
};

int main()
{
	int i = 0;
	struct S* p = (struct S*)malloc(sizeof(struct S));
	p->n = 100;
	p->arr = (int*)malloc(10*sizeof(int));
	for(i=0; i<10; i++)
	{
		p->arr[i] = i;
	}
	for(i=0; i<10; i++)
	{
		printf("%d ", p->arr[i]);
	}
	//释放空间需要注意一下，先放小的在放大的
	free(p->arr);
	p->arr = NULL;

	free(p);
	p = NULL;
	return 0;
}

//上述 代码1 和 代码2 可以完成同样的功能，但是 方法1 的实现有两个好处： 第一个好处是：方便内存释放
//如果我们的代码是在一个给别人用的函数中，你在里面做了二次内存分配，并把整个结构体返回给用户。用
//户调用free可以释放结构体，但是用户并不知道这个结构体内的成员也需要free，所以你不能指望用户来发
//现这个事。所以，如果我们把结构体的内存以及其成员要的内存一次性分配好了，并返回给用户一个结构体
//指针，用户做一次free就可以把所有的内存也给释放掉。
//第二个好处是：这样有利于访问速度.
//连续的内存有益于提高访问速度，也有益于减少内存碎片。（其实，我个人觉得也没多高了，反正你跑不了
//要用做偏移量的加法来寻址）



