#define _CRT_SECURE_NO_WARNINGS 1

//4. 旋转数组。
//方法： 
//例如：k=3；数组为1，2，3，4，5，6，7
//我们令1，2，3，4为（1）
//      5，6，7为（2）
//      1，2，3，4，5，6，7整体为（3）
//1：对（1）先进行逆转：4  3  2  1  
//2：对（2）逆置：7  6  5  
//此时：4  3  2  1  7  6  5
//3：对整体进行你逆转（逆置）（前后对调）
//5 6 7 1 2 3 4 

//void reverse(int *nums, int start, int end)
//{
//	int temp;
//	while (start < end) 
//	{
//		temp = nums[start];
//		nums[start] = nums[end];
//		nums[end] = temp;
//		start++;
//		end--;
//	}
//}
//void rotate(int *nums, int numsSize, int k)
//{
//	k %= numsSize;
//	reverse(nums, 0, numsSize - 1);
//	reverse(nums, 0, k - 1);
//	reverse(nums, k, numsSize - 1);
//}

//5. 数组形式的整数加法。
//对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1, 2, 3, 1]。
//给定非负整数 X 的数组形式 A，返回整数 X + K 的数组形式。
//示例 1：
//输入：A = [1, 2, 0, 0], K = 34
//输出：[1, 2, 3, 4]
//解释：1200 + 34 = 1234
//示例 2：
//输入：A = [2, 7, 4], K = 181
//输出：[4, 5, 5]
//解释：274 + 181 = 455
//示例 3：
//输入：A = [2, 1, 5], K = 806
//输出：[1, 0, 2, 1]
//解释：215 + 806 = 1021
//示例 4：
//输入：A = [9, 9, 9, 9, 9, 9, 9, 9, 9, 9], K = 1
//输出：[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
//解释：9999999999 + 1 = 10000000000

//c语言无法提供的内置类型无法表示上述类型（9999999999999+9999999999）
//则不能对其进行四则混合运算

//方法：将大数按照每一位保存在数组中，用数组来模拟四则运算

//提示：
//1 <= A.length <= 10000
//0 <= A[i] <= 9
//0 <= K <= 10000
//如果 A.length > 1，那么 A[0] != 0

//问题一：运算出的结果我们应该开辟多大的空间
//        举例说明：
//                 A:[2 3] k:10000-----5
//                 A:[2 3] k:9999-----5
//                 A:[999999999]  k:10-----10
//                 A:[2 3] k:999-----4
//保存结果的空间的大小：应该比较长数据位数多一位，因为加完之后最后可能还有一个进位

//用数组中的每一位加k 
//示例 3：
//输入：A = [2, 1, 5], K = 806
//输出：[1, 0, 2, 1]
//解释：215 + 806 = 1021

//步骤：
//(1)806+5= 811 811%10--->1    811/10--->81
//(2)81+1=82 82%10--->2     82/10---->8
//(3)8+2=10 10%10--->0   10/10--->1
//(4)1+0=1 1%10--->1 1/10--->0

//代码实现：
int* addToArrayForm(int* A, int ASize, int K, int* returnSize)
{
	int size = ASize > 5 ? ASize+1 : 5+1;
	//在提示中：1 <= A.length <= 10000
	//          0 <= K <= 10000
	//k最多是5位，而A的长度是1 <= A.length <= 10000
	int* ret = calloc(size, sizeof(int)); //用来返回的所需空间

	//表示加完之后数据的总位数
	int total = 0;  

	//用数组的每一位加k
	int retIdx = size - 1;
	while (ASize > 0)//说明数组里面有元素  //可以保证数组中的元素被加完，K中还有剩余数据
	{
		K += A[ASize - 1];          //数组最低位
		ret[retIdx--] = K % 10;
		K /= 10;
		total++; 
		ASize--;
	}

	while (K > 0)
	{
		ret[retIdx--] = K % 10; 
		K /= 10;
		total++;
	}

	//结果没有超过数组，K的位数大小，则需要搬移
	//原因：我们申请数组结果的空间大小是多一位的（一般情况）
	//      我们最小申请六位空间（当结果小于5位时，则需要搬移2-4位）
	if (total < size)
	{
		//    搬移至    搬移量          搬移多少位
		memmove(ret,ret+(size-total),total*sizeof(int));
	}
	*returnSize = total;

	return ret;
}